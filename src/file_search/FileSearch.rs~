use core::fmt::Error;

use std::{
    fs::{self, File},
    io::{self, BufRead, BufReader},
    path::Path,
};

use tokio::task::{JoinHandle, JoinSet};
pub async fn search_in_files(dir: &Path, word: &str) -> io::Result<Vec<String>> {
    let mut set = JoinSet::new();
    let mut match_arr: Vec<String> = Vec::new();
    for ft in fold_files(dir, word).await {
        set.spawn(ft);
    }
    while let Some(res) = set.join_next().await {
        match_arr.push(res.unwrap());
    }
    Ok(match_arr)
}
async fn fold_files(dir: &Path, word: &str) -> Vec<JoinHandle<io::Result<Vec<String>>>> {
    println!("str:{:?}", &format!(r"{}(\W|$)", word));
    let reg = regex::Regex::new(&format!(r"{}(\W|$)", word))
        .map_err(|e| {
            std::io::Error::new(
                std::io::ErrorKind::Other,
                format!("Failed to build regex {:?}", format!(r"{}(\W|$)", word)),
            )
        })
        .unwrap();
    let mut match_arr: Vec<JoinHandle<io::Result<Vec<String>>>> = Vec::new();
    /*if !dir.exists() {
        return std::io::Result::Err(std::io::Error::new(
            std::io::ErrorKind::NotFound,
            format!("Directory doesn't exist {:?}", dir),
        ));
    }*/
    if dir.is_dir() {
        for entry in fs::read_dir(dir).unwrap() {
            let entry = entry.unwrap();
            let path = entry.path();
            if path.is_dir() {
                match_arr.append(search_in_files(&path, word).unwrap().as_mut());
            } else {
                match_arr.push(do_files(&path, &reg));
            }
        }
    }

    Ok(match_arr)
}
async fn do_files(filepath: &Path, word: &regex::Regex) -> Option<String> {
    if match_file(&path, &reg)? {
        Some(path.into_os_string().into_string().unwrap());
    }
    None
}
async fn match_file(filepath: &Path, word: &regex::Regex) -> io::Result<bool> {
    let file = File::open(filepath)?;
    let reader = BufReader::new(file);
    for _line in reader.lines() {
        let line = if _line.is_ok() {
            _line.unwrap()
        } else {
            println!("Err: failed to read line in {:?}", filepath);
            continue;
        };

        if word.is_match(&line) {
            println!("Found {:?}", filepath);
            return Ok(true);
        }
    }

    Ok(false)
}

#[test]
fn test_search_in_files() {
    assert_eq!(
        vec![format!(
            "{}/src/file_search/tests/test_files/test1.txt",
            std::env::current_dir()
                .unwrap()
                .as_os_str()
                .to_str()
                .unwrap()
        )],
        search_in_files(
            Path::new(&format!(
                "{}/src/file_search/tests",
                std::env::current_dir()
                    .unwrap()
                    .as_os_str()
                    .to_str()
                    .unwrap()
            )),
            "эта"
        )
        .unwrap()
    );
}
#[test]
fn test_recursive_search_in_files() {
    assert_eq!(
        vec![
            format!(
                "{}/src/file_search/tests/test_files/test2.txt",
                std::env::current_dir()
                    .unwrap()
                    .as_os_str()
                    .to_str()
                    .unwrap()
            ),
            format!(
                "{}/src/file_search/tests/test_files/test_files/test2.txt",
                std::env::current_dir()
                    .unwrap()
                    .as_os_str()
                    .to_str()
                    .unwrap()
            )
        ],
        search_in_files(
            Path::new(&format!(
                "{}/src/file_search/tests",
                std::env::current_dir()
                    .unwrap()
                    .as_os_str()
                    .to_str()
                    .unwrap()
            )),
            "трясла"
        )
        .unwrap()
    );
}
#[test]
fn test_search_with_punctiation() {
    assert_eq!(
        vec![format!(
            "{}/src/file_search/tests/test_files/test1.txt",
            std::env::current_dir()
                .unwrap()
                .as_os_str()
                .to_str()
                .unwrap()
        )],
        search_in_files(
            Path::new(&format!(
                "{}/src/file_search/tests",
                std::env::current_dir()
                    .unwrap()
                    .as_os_str()
                    .to_str()
                    .unwrap()
            )),
            "каналам"
        )
        .unwrap()
    );
}
#[test]
fn test_find_multiple_files() {
    assert_eq!(
        vec![
            format!(
                "{}/src/file_search/tests/test_files/test2.txt",
                std::env::current_dir()
                    .unwrap()
                    .as_os_str()
                    .to_str()
                    .unwrap()
            ),
            format!(
                "{}/src/file_search/tests/test_files/test1.txt",
                std::env::current_dir()
                    .unwrap()
                    .as_os_str()
                    .to_str()
                    .unwrap()
            ),
            format!(
                "{}/src/file_search/tests/test_files/test_files/test2.txt",
                std::env::current_dir()
                    .unwrap()
                    .as_os_str()
                    .to_str()
                    .unwrap()
            )
        ],
        search_in_files(
            Path::new(&format!(
                "{}/src/file_search/tests",
                std::env::current_dir()
                    .unwrap()
                    .as_os_str()
                    .to_str()
                    .unwrap()
            )),
            "он"
        )
        .unwrap()
    );
}
